// Added 2025-01-13 21:54:32 UTC - Comprehensive Antimalware Protection System
import { Request, Response, NextFunction } from 'express';
import crypto from 'crypto';
import fs from 'fs/promises';
import path from 'path';

// Malware signature database
interface MalwareSignature {
  id: string;
  name: string;
  pattern: RegExp | string;
  type: 'binary' | 'text' | 'hash';
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

// Common malware signatures and patterns
const MALWARE_SIGNATURES: MalwareSignature[] = [
  // Script injection patterns
  {
    id: 'SCRIPT_INJECTION_1',
    name: 'JavaScript Injection',
    pattern: /<script[\s\S]*?>[\s\S]*?<\/script>/gi,
    type: 'text',
    description: 'Malicious JavaScript injection attempt',
    severity: 'high'
  },
  {
    id: 'SCRIPT_INJECTION_2',
    name: 'Event Handler Injection',
    pattern: /on\w+\s*=\s*['"'][^'"]*['"']/gi,
    type: 'text',
    description: 'HTML event handler injection attempt',
    severity: 'medium'
  },
  
  // SQL injection patterns
  {
    id: 'SQL_INJECTION_1',
    name: 'SQL Injection Union',
    pattern: /(\bunion\b|\bselect\b|\binsert\b|\bupdate\b|\bdelete\b|\bdrop\b).*(\bfrom\b|\binto\b|\btable\b)/gi,
    type: 'text',
    description: 'SQL injection attempt detected',
    severity: 'high'
  },
  
  // Command injection patterns
  {
    id: 'CMD_INJECTION_1',
    name: 'Command Injection',
    pattern: /(\|\||&&|;|\||`|eval\(|system\(|exec\()/gi,
    type: 'text',
    description: 'Command injection attempt detected',
    severity: 'critical'
  },
  
  // Path traversal patterns
  {
    id: 'PATH_TRAVERSAL_1',
    name: 'Path Traversal',
    pattern: /(\.\.[\/\\]){2,}/g,
    type: 'text',
    description: 'Path traversal attack attempt',
    severity: 'high'
  },
  
  // PHP web shell patterns
  {
    id: 'PHP_WEBSHELL_1',
    name: 'PHP Web Shell',
    pattern: /<\?php[\s\S]*?(eval|system|exec|shell_exec|passthru)[\s\S]*?\?>/gi,
    type: 'text',
    description: 'PHP web shell detected',
    severity: 'critical'
  },
  
  // Executable file headers (basic detection)
  {
    id: 'PE_EXECUTABLE',
    name: 'Windows Executable',
    pattern: /^MZ/,
    type: 'binary',
    description: 'Windows PE executable file detected',
    severity: 'medium'
  },
  {
    id: 'ELF_EXECUTABLE',
    name: 'Linux Executable',
    pattern: /^\x7fELF/,
    type: 'binary',
    description: 'Linux ELF executable file detected',
    severity: 'medium'
  },
  
  // Suspicious PowerShell patterns
  {
    id: 'POWERSHELL_MALWARE',
    name: 'Malicious PowerShell',
    pattern: /(Invoke-Expression|IEX|DownloadString|System\.Net\.WebClient|Base64)/gi,
    type: 'text',
    description: 'Suspicious PowerShell code detected',
    severity: 'high'
  }
];

// Known malicious file hashes (example - in production, this would be a larger database)
const MALICIOUS_HASHES = new Set([
  // Example SHA-256 hashes of known malware (these are fictitious for demo)
  '356a192b7913b04c54574d18c28d46e6395428ab',
  'da4b9237bacccdf19c0760cab7aec4a8359010b0',
  'e258d248fda94c63753607f7c4494ee0fcbe92f1'
]);

// File type validation
const ALLOWED_FILE_TYPES = new Set([
  'image/jpeg',
  'image/png', 
  'image/gif',
  'image/webp',
  'application/pdf',
  'text/plain',
  'application/json'
]);

// Maximum file size (10MB)
const MAX_FILE_SIZE = 10 * 1024 * 1024;

// Quarantine directory for suspicious files
const QUARANTINE_DIR = path.join(process.cwd(), 'quarantine');

// Ensure quarantine directory exists
async function ensureQuarantineDir() {
  try {
    await fs.access(QUARANTINE_DIR);
  } catch {
    await fs.mkdir(QUARANTINE_DIR, { recursive: true });
  }
}

// Calculate file hash
async function calculateFileHash(filePath: string): Promise<string> {
  const fileBuffer = await fs.readFile(filePath);
  return crypto.createHash('sha256').update(fileBuffer).digest('hex');
}

// Scan file content for malware signatures
async function scanFileContent(filePath: string): Promise<{
  isClean: boolean;
  threats: MalwareSignature[];
  scanId: string;
}> {
  const scanId = crypto.randomUUID();
  const threats: MalwareSignature[] = [];
  
  try {
    const fileBuffer = await fs.readFile(filePath);
    const fileContent = fileBuffer.toString('utf8');
    const binaryContent = fileBuffer;
    
    // Scan with each signature
    for (const signature of MALWARE_SIGNATURES) {
      let match = false;
      
      if (signature.type === 'text') {
        if (typeof signature.pattern === 'string') {
          match = fileContent.includes(signature.pattern);
        } else {
          match = signature.pattern.test(fileContent);
        }
      } else if (signature.type === 'binary') {
        if (typeof signature.pattern === 'string') {
          match = binaryContent.includes(Buffer.from(signature.pattern));
        } else {
          match = signature.pattern.test(binaryContent.toString('binary'));
        }
      }
      
      if (match) {
        threats.push(signature);
        console.warn(`ü¶† Malware signature detected: ${signature.name} (${signature.id})`);
      }
    }
    
    // Log scan results
    console.log(`üîç Antimalware scan complete [${scanId}]:`, {
      file: path.basename(filePath),
      size: fileBuffer.length,
      threatsFound: threats.length,
      isClean: threats.length === 0,
      timestamp: new Date().toISOString()
    });
    
    return {
      isClean: threats.length === 0,
      threats,
      scanId
    };
    
  } catch (error) {
    console.error(`‚ùå Error scanning file ${filePath}:`, error);
    return {
      isClean: false,
      threats: [{
        id: 'SCAN_ERROR',
        name: 'Scan Error',
        pattern: '',
        type: 'text',
        description: 'Failed to scan file for malware',
        severity: 'medium'
      }],
      scanId
    };
  }
}

// Quarantine suspicious file
async function quarantineFile(filePath: string, reason: string): Promise<string> {
  await ensureQuarantineDir();
  
  const fileName = path.basename(filePath);
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const quarantinePath = path.join(QUARANTINE_DIR, `${timestamp}_${fileName}`);
  
  try {
    await fs.copyFile(filePath, quarantinePath);
    await fs.unlink(filePath); // Remove original file
    
    // Create metadata file
    const metadataPath = quarantinePath + '.metadata.json';
    const metadata = {
      originalPath: filePath,
      quarantineTime: new Date().toISOString(),
      reason,
      scanId: crypto.randomUUID(),
      size: (await fs.stat(quarantinePath)).size
    };
    
    await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
    
    console.warn(`üö® File quarantined: ${fileName} -> ${quarantinePath}`);
    console.warn(`üìã Quarantine reason: ${reason}`);
    
    return quarantinePath;
  } catch (error) {
    console.error(`‚ùå Failed to quarantine file ${filePath}:`, error);
    throw error;
  }
}

// Main antimalware middleware for file uploads
export const antimalwareFileScanner = async (req: Request, res: Response, next: NextFunction) => {
  if (!req.file && !req.files) {
    return next();
  }
  
  const files = req.files ? (Array.isArray(req.files) ? req.files : Object.values(req.files).flat()) : [req.file];
  
  try {
    for (const file of files.filter(f => f)) {
      // File size check
      if (file.size > MAX_FILE_SIZE) {
        await quarantineFile(file.path, `File too large: ${file.size} bytes`);
        return res.status(413).json({
          success: false,
          error: {
            message: 'File too large for security scanning',
            statusCode: 413,
            scanId: crypto.randomUUID()
          },
          timestamp: new Date().toISOString()
        });
      }
      
      // File type check
      if (!ALLOWED_FILE_TYPES.has(file.mimetype)) {
        await quarantineFile(file.path, `Unauthorized file type: ${file.mimetype}`);
        return res.status(415).json({
          success: false,
          error: {
            message: 'Unauthorized file type detected',
            statusCode: 415,
            fileType: file.mimetype,
            scanId: crypto.randomUUID()
          },
          timestamp: new Date().toISOString()
        });
      }
      
      // Calculate file hash and check against known malicious hashes
      const fileHash = await calculateFileHash(file.path);
      if (MALICIOUS_HASHES.has(fileHash)) {
        await quarantineFile(file.path, `Known malicious file hash: ${fileHash}`);
        return res.status(403).json({
          success: false,
          error: {
            message: 'Known malicious file detected',
            statusCode: 403,
            hash: fileHash,
            scanId: crypto.randomUUID()
          },
          timestamp: new Date().toISOString()
        });
      }
      
      // Scan file content for malware
      const scanResult = await scanFileContent(file.path);
      
      if (!scanResult.isClean) {
        const criticalThreats = scanResult.threats.filter(t => t.severity === 'critical');
        const highThreats = scanResult.threats.filter(t => t.severity === 'high');
        
        // Quarantine file if critical or high severity threats found
        if (criticalThreats.length > 0 || highThreats.length > 0) {
          const threatList = scanResult.threats.map(t => `${t.name} (${t.severity})`).join(', ');
          await quarantineFile(file.path, `Malware detected: ${threatList}`);
          
          return res.status(403).json({
            success: false,
            error: {
              message: 'Malware detected in uploaded file',
              statusCode: 403,
              threats: scanResult.threats.map(t => ({
                name: t.name,
                severity: t.severity,
                description: t.description
              })),
              scanId: scanResult.scanId
            },
            timestamp: new Date().toISOString()
          });
        }
      }
      
      // Add scan metadata to file object
      (file as any).scanResult = scanResult;
      (file as any).fileHash = fileHash;
    }
    
    next();
    
  } catch (error) {
    console.error('‚ùå Antimalware scanning error:', error);
    return res.status(500).json({
      success: false,
      error: {
        message: 'Antimalware scanning failed',
        statusCode: 500,
        scanId: crypto.randomUUID()
      },
      timestamp: new Date().toISOString()
    });
  }
};

// Antimalware middleware for request payloads (JSON/text)
export const antimalwarePayloadScanner = (req: Request, res: Response, next: NextFunction) => {
  const scanId = crypto.randomUUID();
  
  try {
    // Scan request body
    if (req.body) {
      const bodyContent = JSON.stringify(req.body);
      const threats: MalwareSignature[] = [];
      
      // Check for malicious patterns in request body
      for (const signature of MALWARE_SIGNATURES.filter(s => s.type === 'text')) {
        let match = false;
        
        if (typeof signature.pattern === 'string') {
          match = bodyContent.includes(signature.pattern);
        } else {
          match = signature.pattern.test(bodyContent);
        }
        
        if (match) {
          threats.push(signature);
        }
      }
      
      if (threats.length > 0) {
        const criticalThreats = threats.filter(t => t.severity === 'critical');
        const highThreats = threats.filter(t => t.severity === 'high');
        
        // Block request if critical or high severity threats found
        if (criticalThreats.length > 0 || highThreats.length > 0) {
          console.warn(`ü¶† Malicious payload blocked from IP ${req.ip}:`, {
            threats: threats.map(t => t.name),
            path: req.path,
            method: req.method,
            scanId,
            timestamp: new Date().toISOString()
          });
          
          return res.status(403).json({
            success: false,
            error: {
              message: 'Malicious content detected in request',
              statusCode: 403,
              scanId
            },
            timestamp: new Date().toISOString()
          });
        }
      }
    }
    
    next();
    
  } catch (error) {
    console.error('‚ùå Payload antimalware scanning error:', error);
    next(); // Continue on scanning errors for availability
  }
};

// Get quarantine status and statistics
export const getQuarantineStats = async (): Promise<{
  totalQuarantined: number;
  recentQuarantine: any[];
  quarantineSize: number;
}> => {
  try {
    await ensureQuarantineDir();
    const files = await fs.readdir(QUARANTINE_DIR);
    const metadataFiles = files.filter(f => f.endsWith('.metadata.json'));
    
    let totalSize = 0;
    const recent = [];
    
    for (const metadataFile of metadataFiles.slice(-10)) {
      try {
        const metadataPath = path.join(QUARANTINE_DIR, metadataFile);
        const metadata = JSON.parse(await fs.readFile(metadataPath, 'utf8'));
        recent.push(metadata);
        totalSize += metadata.size || 0;
      } catch (error) {
        console.error(`Error reading quarantine metadata ${metadataFile}:`, error);
      }
    }
    
    return {
      totalQuarantined: metadataFiles.length,
      recentQuarantine: recent,
      quarantineSize: totalSize
    };
  } catch (error) {
    console.error('Error getting quarantine stats:', error);
    return {
      totalQuarantined: 0,
      recentQuarantine: [],
      quarantineSize: 0
    };
  }
};

// Admin endpoint to manage quarantine
export const manageQuarantine = {
  // List quarantined files
  list: async (req: Request, res: Response) => {
    try {
      const stats = await getQuarantineStats();
      res.json({
        success: true,
        data: stats,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: {
          message: 'Failed to retrieve quarantine information',
          statusCode: 500
        },
        timestamp: new Date().toISOString()
      });
    }
  },
  
  // Clean quarantine (remove old files)
  clean: async (req: Request, res: Response) => {
    try {
      await ensureQuarantineDir();
      const files = await fs.readdir(QUARANTINE_DIR);
      const cutoffDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days ago
      
      let cleanedCount = 0;
      
      for (const file of files) {
        try {
          const filePath = path.join(QUARANTINE_DIR, file);
          const stats = await fs.stat(filePath);
          
          if (stats.birthtime < cutoffDate) {
            await fs.unlink(filePath);
            cleanedCount++;
          }
        } catch (error) {
          console.error(`Error cleaning quarantine file ${file}:`, error);
        }
      }
      
      res.json({
        success: true,
        data: {
          cleanedFiles: cleanedCount,
          cleanupDate: cutoffDate.toISOString()
        },
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: {
          message: 'Failed to clean quarantine',
          statusCode: 500
        },
        timestamp: new Date().toISOString()
      });
    }
  }
};